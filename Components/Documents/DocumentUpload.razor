@using finaid.Models.UI
@using finaid.Models.Documents
@using finaid.Services.Documents
@using Microsoft.AspNetCore.Components.Forms
@inject IDocumentUIService DocumentUIService
@inject IJSRuntime JSRuntime
@inject ILogger<DocumentUpload> Logger
@implements IDisposable

<div class="document-upload-container">
    <div class="upload-section">
        <div class="upload-dropzone @(isDragOver ? "drag-over" : "")" 
             @ondragenter="HandleDragEnter" 
             @ondragover="HandleDragOver" 
             @ondragleave="HandleDragLeave" 
             @ondrop="HandleDrop"
             @onclick="TriggerFileInput">
            
            <InputFile @ref="fileInputRef" 
                      OnChange="HandleFileSelection" 
                      multiple 
                      accept=".pdf,.jpg,.jpeg,.png,.tiff,.tif" 
                      style="display: none;" />
            
            <div class="upload-instructions">
                <i class="bi bi-cloud-upload fs-1 text-primary mb-3"></i>
                <h5 class="mb-2">Upload Your Documents</h5>
                <p class="text-muted mb-3">
                    Drag and drop your documents here or click to browse
                </p>
                <div class="upload-requirements">
                    <small class="text-muted">
                        <strong>Supported formats:</strong> PDF, JPG, PNG, TIFF<br>
                        <strong>Maximum size:</strong> 50MB per file<br>
                        <strong>Maximum files:</strong> 10 files at once
                    </small>
                </div>
                
                @if (!string.IsNullOrEmpty(uploadError))
                {
                    <div class="alert alert-danger mt-3 mb-0" role="alert">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        @uploadError
                    </div>
                }
            </div>
        </div>
    </div>

    @if (activeUploads.Any())
    {
        <div class="upload-queue mt-4">
            <div class="upload-queue-header">
                <h5 class="mb-0">
                    <i class="bi bi-upload me-2"></i>
                    Upload Progress (@activeUploads.Count)
                </h5>
                @if (activeUploads.Any(u => u.Status == UploadStatus.Uploading || u.Status == UploadStatus.Processing))
                {
                    <button type="button" class="btn btn-sm btn-outline-danger" @onclick="CancelAllUploads">
                        <i class="bi bi-stop-fill me-1"></i>
                        Cancel All
                    </button>
                }
            </div>
            
            <div class="upload-queue-items">
                @foreach (var upload in activeUploads.OrderByDescending(u => u.StartedAt))
                {
                    <UploadProgress Upload="upload" 
                                   OnCancel="HandleCancelUpload" 
                                   OnRetry="HandleRetryUpload" />
                }
            </div>
        </div>
    }

    @if (userDocuments.Any() || isLoadingDocuments)
    {
        <div class="documents-section mt-4">
            <div class="documents-header">
                <h5 class="mb-0">
                    <i class="bi bi-files me-2"></i>
                    My Documents (@userDocuments.Count)
                </h5>
                <button type="button" class="btn btn-sm btn-outline-primary" @onclick="RefreshDocuments">
                    <i class="bi bi-arrow-clockwise me-1"></i>
                    Refresh
                </button>
            </div>
            
            @if (isLoadingDocuments)
            {
                <div class="text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading documents...</span>
                    </div>
                    <div class="mt-2">Loading your documents...</div>
                </div>
            }
            else
            {
                <DocumentList Documents="userDocuments" OnDocumentDelete="HandleDocumentDelete" />
            }
        </div>
    }
</div>

@code {
    [Parameter] public Guid UserId { get; set; }
    [Parameter] public EventCallback<List<DocumentMetadata>> OnDocumentsChanged { get; set; }

    private InputFile? fileInputRef;
    private bool isDragOver = false;
    private string uploadError = string.Empty;
    private List<DocumentUploadState> activeUploads = new();
    private List<DocumentMetadata> userDocuments = new();
    private bool isLoadingDocuments = false;

    protected override async Task OnInitializedAsync()
    {
        DocumentUIService.UploadStateChanged += OnUploadStateChanged;
        DocumentUIService.DocumentListChanged += OnDocumentListChanged;
        
        await LoadUserDocuments();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("documentUpload.initialize", DotNetObjectReference.Create(this));
        }
    }

    private async Task HandleFileSelection(InputFileChangeEventArgs e)
    {
        uploadError = string.Empty;
        
        try
        {
            var files = e.GetMultipleFiles(10); // Maximum 10 files
            
            foreach (var file in files)
            {
                if (await ValidateFile(file))
                {
                    var uploadState = await DocumentUIService.StartUploadAsync(file, UserId);
                    activeUploads.Add(uploadState);
                }
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling file selection");
            uploadError = "An error occurred while processing your files. Please try again.";
            StateHasChanged();
        }
    }

    private Task<bool> ValidateFile(IBrowserFile file)
    {
        // File size validation
        if (file.Size > 50 * 1024 * 1024) // 50MB
        {
            uploadError = $"File '{file.Name}' is too large. Maximum file size is 50MB.";
            return Task.FromResult(false);
        }

        // File type validation
        var allowedTypes = new[] { ".pdf", ".jpg", ".jpeg", ".png", ".tiff", ".tif" };
        var extension = Path.GetExtension(file.Name).ToLowerInvariant();
        
        if (!allowedTypes.Contains(extension))
        {
            uploadError = $"File type '{extension}' is not supported. Please upload PDF, JPG, PNG, or TIFF files only.";
            return Task.FromResult(false);
        }

        return Task.FromResult(true);
    }

    private void HandleDragEnter()
    {
        isDragOver = true;
    }

    private void HandleDragOver()
    {
        isDragOver = true;
    }

    private void HandleDragLeave()
    {
        isDragOver = false;
    }

    private Task HandleDrop()
    {
        isDragOver = false;
        // File handling is managed by the InputFile component
        return Task.CompletedTask;
    }

    private async Task TriggerFileInput()
    {
        await JSRuntime.InvokeVoidAsync("documentUpload.triggerFileInput");
    }

    private async Task HandleCancelUpload(DocumentUploadState upload)
    {
        await DocumentUIService.CancelUploadAsync(upload.Id);
    }

    private async Task HandleRetryUpload(DocumentUploadState upload)
    {
        await DocumentUIService.RetryUploadAsync(upload.Id);
    }

    private async Task CancelAllUploads()
    {
        var activeUploadsToCancel = activeUploads
            .Where(u => u.Status == UploadStatus.Uploading || u.Status == UploadStatus.Processing)
            .ToList();
            
        foreach (var upload in activeUploadsToCancel)
        {
            await DocumentUIService.CancelUploadAsync(upload.Id);
        }
    }

    private async Task LoadUserDocuments()
    {
        isLoadingDocuments = true;
        StateHasChanged();
        
        try
        {
            userDocuments = await DocumentUIService.GetUserDocumentsAsync(UserId);
            
            if (OnDocumentsChanged.HasDelegate)
            {
                await OnDocumentsChanged.InvokeAsync(userDocuments);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load user documents");
        }
        finally
        {
            isLoadingDocuments = false;
            StateHasChanged();
        }
    }

    private async Task RefreshDocuments()
    {
        await LoadUserDocuments();
    }

    private async Task HandleDocumentDelete(Guid documentId)
    {
        try
        {
            var success = await DocumentUIService.DeleteDocumentAsync(documentId);
            if (success)
            {
                userDocuments.RemoveAll(d => d.Id == documentId);
                StateHasChanged();
                
                if (OnDocumentsChanged.HasDelegate)
                {
                    await OnDocumentsChanged.InvokeAsync(userDocuments);
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to delete document {DocumentId}", documentId);
        }
    }

    private void OnUploadStateChanged(DocumentUploadState uploadState)
    {
        InvokeAsync(() =>
        {
            var existingUpload = activeUploads.FirstOrDefault(u => u.Id == uploadState.Id);
            if (existingUpload != null)
            {
                var index = activeUploads.IndexOf(existingUpload);
                activeUploads[index] = uploadState;
            }
            else
            {
                activeUploads.Add(uploadState);
            }

            // Remove completed, failed, or cancelled uploads after a delay
            if (uploadState.Status is UploadStatus.Completed or UploadStatus.Failed or UploadStatus.Cancelled)
            {
                _ = Task.Delay(10000).ContinueWith(_ =>
                {
                    InvokeAsync(() =>
                    {
                        activeUploads.RemoveAll(u => u.Id == uploadState.Id);
                        StateHasChanged();
                    });
                });
            }

            StateHasChanged();
        });
    }

    private void OnDocumentListChanged(List<DocumentMetadata> documents)
    {
        InvokeAsync(() =>
        {
            userDocuments = documents;
            StateHasChanged();
        });
    }

    [JSInvokable]
    public async Task OnFilesDropped()
    {
        // This will be called from JavaScript when files are dropped
        // The actual file processing is handled by the InputFile component
        await Task.CompletedTask;
    }

    public void Dispose()
    {
        DocumentUIService.UploadStateChanged -= OnUploadStateChanged;
        DocumentUIService.DocumentListChanged -= OnDocumentListChanged;
    }
}

<style>
    .document-upload-container {
        width: 100%;
        max-width: 100%;
    }

    .upload-dropzone {
        border: 2px dashed var(--bs-border-color);
        border-radius: 0.5rem;
        padding: 3rem 2rem;
        text-align: center;
        background-color: var(--bs-body-bg);
        cursor: pointer;
        transition: all 0.2s ease-in-out;
        position: relative;
        min-height: 200px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .upload-dropzone:hover {
        border-color: var(--bs-primary);
        background-color: rgba(13, 110, 253, 0.05);
    }

    .upload-dropzone.drag-over {
        border-color: var(--bs-success);
        background-color: rgba(25, 135, 84, 0.1);
        border-style: solid;
    }

    .upload-instructions {
        max-width: 400px;
    }

    .upload-requirements {
        background-color: var(--bs-gray-100);
        border-radius: 0.375rem;
        padding: 0.75rem;
        margin-top: 1rem;
        line-height: 1.4;
    }

    .upload-queue {
        background-color: var(--bs-gray-50);
        border-radius: 0.5rem;
        padding: 1.5rem;
    }

    .upload-queue-header,
    .documents-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid var(--bs-border-color);
    }

    .upload-queue-items {
        max-height: 400px;
        overflow-y: auto;
    }

    .documents-section {
        background-color: var(--bs-body-bg);
        border: 1px solid var(--bs-border-color);
        border-radius: 0.5rem;
        padding: 1.5rem;
    }

    @@media (max-width: 768px) {
        .upload-dropzone {
            padding: 2rem 1rem;
        }

        .upload-instructions h5 {
            font-size: 1.1rem;
        }

        .upload-queue,
        .documents-section {
            padding: 1rem;
        }

        .upload-queue-header,
        .documents-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 0.5rem;
        }
    }
</style>