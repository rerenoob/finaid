@using finaid.Models.AI
@using finaid.Models.Chat
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.Json
@inject IJSRuntime JSRuntime
@inject ILogger<ChatInterface> Logger
@implements IAsyncDisposable

<div class="chat-container" id="chat-container-@ComponentId">
    <div class="chat-header">
        <div class="chat-title">
            <h4>@Title</h4>
            @if (!string.IsNullOrEmpty(SessionType))
            {
                <span class="badge badge-primary session-type">@SessionType.ToUpper()</span>
            }
        </div>
        <div class="chat-actions">
            @if (AllowNewChat)
            {
                <button class="btn btn-sm btn-outline-secondary" @onclick="StartNewConversation" disabled="@IsProcessing">
                    <i class="fas fa-plus"></i> New Chat
                </button>
            }
            @if (AllowClear)
            {
                <button class="btn btn-sm btn-outline-danger" @onclick="ClearConversation" disabled="@IsProcessing">
                    <i class="fas fa-trash"></i> Clear
                </button>
            }
        </div>
    </div>

    <div class="chat-messages" @ref="MessagesContainer" id="messages-@ComponentId">
        @if (IsLoading)
        {
            <div class="loading-indicator">
                <div class="spinner-border spinner-border-sm" role="status">
                    <span class="sr-only">Loading...</span>
                </div>
                <span class="ml-2">Loading conversation...</span>
            </div>
        }
        else
        {
            @foreach (var message in Messages)
            {
                <ChatMessageDisplay Message="message" ShowMetadata="ShowMessageMetadata" />
            }
        }

        @if (IsAITyping)
        {
            <TypingIndicator />
        }

        @if (IsStreaming && !string.IsNullOrEmpty(StreamingContent))
        {
            <div class="message ai-message streaming">
                <div class="message-avatar">
                    <i class="fas fa-robot"></i>
                </div>
                <div class="message-content">
                    <div class="message-bubble">
                        @((MarkupString)FormatMessage(StreamingContent))
                        <span class="streaming-cursor">|</span>
                    </div>
                </div>
            </div>
        }

        <div @ref="ScrollAnchor" class="scroll-anchor"></div>
    </div>

    @if (SuggestedActions.Any())
    {
        <div class="suggested-actions">
            <div class="suggested-actions-label">Suggested actions:</div>
            @foreach (var action in SuggestedActions.Take(3))
            {
                <button class="btn btn-sm btn-outline-primary suggested-action" 
                        @onclick="() => SelectSuggestedAction(action)"
                        disabled="@IsProcessing">
                    @action
                </button>
            }
        </div>
    }

    <MessageInput OnMessageSent="HandleMessageSent" 
                  IsEnabled="@(!IsProcessing && !IsLoading)" 
                  Placeholder="@InputPlaceholder"
                  ShowFormContext="@ShowFormContextToggle" />

    @if (ShowConnectionStatus)
    {
        <div class="connection-status @(IsConnected ? "connected" : "disconnected")">
            <i class="fas @(IsConnected ? "fa-check-circle" : "fa-times-circle")"></i>
            @(IsConnected ? "Connected" : "Disconnected")
        </div>
    }
</div>

@code {
    [Parameter] public string? SessionId { get; set; }
    [Parameter] public string? UserId { get; set; }
    [Parameter] public string SessionType { get; set; } = "general";
    [Parameter] public string Title { get; set; } = "AI Assistant";
    [Parameter] public string InputPlaceholder { get; set; } = "Type your message...";
    [Parameter] public bool AllowNewChat { get; set; } = true;
    [Parameter] public bool AllowClear { get; set; } = true;
    [Parameter] public bool ShowMessageMetadata { get; set; } = false;
    [Parameter] public bool ShowConnectionStatus { get; set; } = false;
    [Parameter] public bool ShowFormContextToggle { get; set; } = false;
    [Parameter] public bool AutoScroll { get; set; } = true;
    [Parameter] public bool EnableStreaming { get; set; } = false;
    [Parameter] public EventCallback<ConversationSession> OnSessionCreated { get; set; }
    [Parameter] public EventCallback<string> OnSessionCleared { get; set; }
    [Parameter] public EventCallback<finaid.Models.AI.ChatMessage> OnMessageReceived { get; set; }
    [Parameter] public object? FormContext { get; set; }

    private HubConnection? _hubConnection;
    private List<finaid.Models.AI.ChatMessage> Messages = new();
    private List<string> SuggestedActions = new();
    private ElementReference MessagesContainer;
    private ElementReference ScrollAnchor;
    private string ComponentId = Guid.NewGuid().ToString("N")[..8];
    
    private bool IsConnected = false;
    private bool IsProcessing = false;
    private bool IsLoading = false;
    private bool IsAITyping = false;
    private bool IsStreaming = false;
    private string StreamingContent = string.Empty;
    private string? CurrentStreamingId;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await InitializeSignalRConnection();
            await LoadSessionHistory();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing chat interface");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (AutoScroll && Messages.Any())
        {
            try
            {
                await ScrollToBottom();
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Error scrolling to bottom");
            }
        }
    }

    private async Task InitializeSignalRConnection()
    {
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl("/hubs/chat")
                .WithAutomaticReconnect()
                .Build();

            // Register event handlers
            _hubConnection.On<finaid.Models.AI.ChatMessage>("MessageReceived", HandleMessageReceived);
            _hubConnection.On<List<string>>("SuggestedActions", HandleSuggestedActions);
            _hubConnection.On<string, bool>("UserTyping", HandleUserTyping);
            _hubConnection.On<bool>("AITyping", HandleAITyping);
            _hubConnection.On<string, string>("StreamingChunk", HandleStreamingChunk);
            _hubConnection.On("AIStreamingStart", HandleStreamingStart);
            _hubConnection.On<string>("AIStreamingComplete", HandleStreamingComplete);
            _hubConnection.On<string>("AIStreamingError", HandleStreamingError);
            _hubConnection.On<string>("Error", HandleError);
            _hubConnection.On<List<finaid.Models.AI.ChatMessage>>("SessionHistory", HandleSessionHistory);

            _hubConnection.Reconnecting += OnReconnecting;
            _hubConnection.Reconnected += OnReconnected;
            _hubConnection.Closed += OnConnectionClosed;

            await _hubConnection.StartAsync();
            IsConnected = true;

            if (!string.IsNullOrEmpty(SessionId))
            {
                await _hubConnection.SendAsync("JoinSession", SessionId);
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize SignalR connection");
            IsConnected = false;
        }
    }

    private async Task LoadSessionHistory()
    {
        if (!string.IsNullOrEmpty(SessionId) && _hubConnection?.State == HubConnectionState.Connected)
        {
            try
            {
                IsLoading = true;
                StateHasChanged();
                await _hubConnection.SendAsync("RequestSessionHistory", SessionId);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error loading session history");
                IsLoading = false;
            }
        }
    }

    private async Task HandleMessageSent(MessageSentEventArgs args)
    {
        if (_hubConnection?.State != HubConnectionState.Connected || string.IsNullOrEmpty(SessionId))
            return;

        try
        {
            IsProcessing = true;
            SuggestedActions.Clear();
            StateHasChanged();

            var formContextJson = FormContext != null ? JsonSerializer.Serialize(FormContext) : null;

            if (EnableStreaming)
            {
                await _hubConnection.SendAsync("SendStreamingMessage", SessionId, args.Message, formContextJson);
            }
            else
            {
                await _hubConnection.SendAsync("SendMessage", SessionId, args.Message, formContextJson);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error sending message");
            IsProcessing = false;
            StateHasChanged();
        }
    }

    private async Task HandleMessageReceived(finaid.Models.AI.ChatMessage message)
    {
        try
        {
            Messages.Add(message);
            IsProcessing = false;
            
            if (OnMessageReceived.HasDelegate)
            {
                await OnMessageReceived.InvokeAsync(message);
            }

            StateHasChanged();
            
            if (AutoScroll)
            {
                await ScrollToBottom();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling received message");
        }
    }

    private async Task HandleSuggestedActions(List<string> actions)
    {
        SuggestedActions = actions ?? new List<string>();
        StateHasChanged();
    }

    private async Task HandleUserTyping(string connectionId, bool isTyping)
    {
        // Handle other users typing (could show indicators)
        StateHasChanged();
    }

    private async Task HandleAITyping(bool isTyping)
    {
        IsAITyping = isTyping;
        StateHasChanged();
        
        if (AutoScroll)
        {
            await ScrollToBottom();
        }
    }

    private async Task HandleStreamingChunk(string streamingId, string chunk)
    {
        if (CurrentStreamingId == streamingId)
        {
            StreamingContent += chunk;
            StateHasChanged();
            
            if (AutoScroll)
            {
                await ScrollToBottom();
            }
        }
    }

    private async Task HandleStreamingStart()
    {
        IsStreaming = true;
        IsProcessing = true;
        CurrentStreamingId = Guid.NewGuid().ToString();
        StreamingContent = string.Empty;
        StateHasChanged();
    }

    private async Task HandleStreamingComplete(string streamingId)
    {
        IsStreaming = false;
        IsProcessing = false;
        
        // Convert streaming content to actual message
        if (!string.IsNullOrEmpty(StreamingContent))
        {
            var aiMessage = ChatMessageFactory.CreateAssistantMessage(StreamingContent);
            Messages.Add(aiMessage);
        }
        
        StreamingContent = string.Empty;
        CurrentStreamingId = null;
        StateHasChanged();
    }

    private async Task HandleStreamingError(string error)
    {
        IsStreaming = false;
        IsProcessing = false;
        Logger.LogError("Streaming error: {Error}", error);
        
        var errorMessage = ChatMessageFactory.CreateErrorMessage($"Streaming error: {error}");
        Messages.Add(errorMessage);
        
        StreamingContent = string.Empty;
        CurrentStreamingId = null;
        StateHasChanged();
    }

    private async Task HandleError(string error)
    {
        Logger.LogError("Chat error: {Error}", error);
        IsProcessing = false;
        
        var errorMessage = ChatMessageFactory.CreateErrorMessage(error);
        Messages.Add(errorMessage);
        
        StateHasChanged();
    }

    private async Task HandleSessionHistory(List<finaid.Models.AI.ChatMessage> history)
    {
        Messages = history ?? new List<finaid.Models.AI.ChatMessage>();
        IsLoading = false;
        StateHasChanged();
        
        if (AutoScroll && Messages.Any())
        {
            await ScrollToBottom();
        }
    }

    private async Task SelectSuggestedAction(string action)
    {
        await HandleMessageSent(new MessageSentEventArgs(action, false));
    }

    private async Task StartNewConversation()
    {
        try
        {
            Messages.Clear();
            SuggestedActions.Clear();
            
            // Leave current session if any
            if (!string.IsNullOrEmpty(SessionId) && _hubConnection?.State == HubConnectionState.Connected)
            {
                await _hubConnection.SendAsync("LeaveSession", SessionId);
            }

            // Generate new session ID
            SessionId = Guid.NewGuid().ToString();
            
            // Join new session
            if (_hubConnection?.State == HubConnectionState.Connected)
            {
                await _hubConnection.SendAsync("JoinSession", SessionId);
            }

            StateHasChanged();

            if (OnSessionCreated.HasDelegate)
            {
                var newSession = new ConversationSession
                {
                    Id = Guid.Parse(SessionId),
                    UserId = Guid.TryParse(UserId, out var uid) ? uid : Guid.NewGuid(),
                    SessionType = SessionType
                };
                await OnSessionCreated.InvokeAsync(newSession);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting new conversation");
        }
    }

    private async Task ClearConversation()
    {
        try
        {
            Messages.Clear();
            SuggestedActions.Clear();
            StateHasChanged();

            if (OnSessionCleared.HasDelegate && !string.IsNullOrEmpty(SessionId))
            {
                await OnSessionCleared.InvokeAsync(SessionId);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error clearing conversation");
        }
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("scrollToBottom", $"messages-{ComponentId}");
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Error scrolling to bottom");
        }
    }

    private static string FormatMessage(string content)
    {
        // Simple markdown-style formatting
        content = System.Web.HttpUtility.HtmlEncode(content);
        content = content.Replace("\n", "<br>");
        
        // Bold text **text**
        content = System.Text.RegularExpressions.Regex.Replace(content, @"\*\*(.*?)\*\*", "<strong>$1</strong>");
        
        // Italic text *text*
        content = System.Text.RegularExpressions.Regex.Replace(content, @"\*(.*?)\*", "<em>$1</em>");
        
        return content;
    }

    // SignalR connection event handlers
    private async Task OnReconnecting(Exception? exception)
    {
        IsConnected = false;
        StateHasChanged();
    }

    private async Task OnReconnected(string? connectionId)
    {
        IsConnected = true;
        if (!string.IsNullOrEmpty(SessionId))
        {
            await _hubConnection!.SendAsync("JoinSession", SessionId);
        }
        StateHasChanged();
    }

    private async Task OnConnectionClosed(Exception? exception)
    {
        IsConnected = false;
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection != null)
        {
            try
            {
                if (!string.IsNullOrEmpty(SessionId) && _hubConnection.State == HubConnectionState.Connected)
                {
                    await _hubConnection.SendAsync("LeaveSession", SessionId);
                }
                await _hubConnection.DisposeAsync();
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Error disposing SignalR connection");
            }
        }
    }
}