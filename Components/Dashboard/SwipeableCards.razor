@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime

@*
    Swipeable card container for mobile dashboard navigation
*@

<div class="swipeable-cards" @ref="containerRef">
    <div class="cards-track" style="transform: translateX(@($"-{currentIndex * 100}%"))">
        @ChildContent
    </div>
</div>

@code {
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public EventCallback<int> OnCardSwipe { get; set; }
    [Parameter] public bool EnableSwipe { get; set; } = true;
    [Parameter] public double SwipeThreshold { get; set; } = 50; // pixels
    [Parameter] public int AnimationDuration { get; set; } = 300; // milliseconds

    private ElementReference containerRef;
    private int currentIndex = 0;
    private int totalCards = 0;
    private bool isInitialized = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && EnableSwipe)
        {
            try
            {
                await InitializeSwipeGestures();
                await CountCards();
                isInitialized = true;
            }
            catch (Exception ex)
            {
                // Handle JS interop errors gracefully
                Console.WriteLine($"Error initializing swipe gestures: {ex.Message}");
            }
        }
    }

    private async Task InitializeSwipeGestures()
    {
        await JSRuntime.InvokeVoidAsync("eval", $@"
            (function() {{
                const container = document.querySelector('[data-swipeable-container]') || arguments[0];
                let startX = 0;
                let currentX = 0;
                let isDragging = false;
                let startTime = 0;

                function handleStart(e) {{
                    isDragging = true;
                    startX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                    currentX = startX;
                    startTime = Date.now();
                    container.style.cursor = 'grabbing';
                    e.preventDefault();
                }}

                function handleMove(e) {{
                    if (!isDragging) return;
                    
                    currentX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                    const deltaX = currentX - startX;
                    const track = container.querySelector('.cards-track');
                    
                    if (track) {{
                        const currentTransform = -{currentIndex * 100}% + (deltaX / container.offsetWidth * 100)%;
                        track.style.transform = `translateX(${{currentTransform}}%)`;
                        track.style.transition = 'none';
                    }}
                    
                    e.preventDefault();
                }}

                function handleEnd(e) {{
                    if (!isDragging) return;
                    isDragging = false;
                    
                    const deltaX = currentX - startX;
                    const deltaTime = Date.now() - startTime;
                    const velocity = Math.abs(deltaX) / deltaTime;
                    const track = container.querySelector('.cards-track');
                    
                    container.style.cursor = 'grab';
                    
                    if (track) {{
                        track.style.transition = 'transform {AnimationDuration}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        
                        let shouldSwipe = false;
                        let newIndex = {currentIndex};
                        
                        // Determine if swipe should trigger navigation
                        if (Math.abs(deltaX) > {SwipeThreshold} || velocity > 0.5) {{
                            if (deltaX > 0 && {currentIndex} > 0) {{
                                // Swipe right - go to previous card
                                newIndex = {currentIndex} - 1;
                                shouldSwipe = true;
                            }} else if (deltaX < 0 && {currentIndex} < {totalCards} - 1) {{
                                // Swipe left - go to next card
                                newIndex = {currentIndex} + 1;
                                shouldSwipe = true;
                            }}
                        }}
                        
                        if (shouldSwipe) {{
                            DotNet.invokeMethodAsync('{GetType().Assembly.GetName().Name}', 'OnSwipeNavigate', newIndex);
                        }} else {{
                            // Snap back to current position
                            track.style.transform = `translateX(-{currentIndex * 100}%)`;
                        }}
                    }}
                    
                    e.preventDefault();
                }}

                // Mouse events
                container.addEventListener('mousedown', handleStart);
                container.addEventListener('mousemove', handleMove);
                container.addEventListener('mouseup', handleEnd);
                container.addEventListener('mouseleave', handleEnd);

                // Touch events
                container.addEventListener('touchstart', handleStart, {{ passive: false }});
                container.addEventListener('touchmove', handleMove, {{ passive: false }});
                container.addEventListener('touchend', handleEnd, {{ passive: false }});

                // Prevent context menu on long press
                container.addEventListener('contextmenu', e => e.preventDefault());
                
                // Set initial cursor
                container.style.cursor = 'grab';
                container.setAttribute('data-swipeable-container', 'true');
            }})();
        ", containerRef);
    }

    private async Task CountCards()
    {
        try
        {
            totalCards = await JSRuntime.InvokeAsync<int>("eval", @"
                (function() {
                    const track = arguments[0].querySelector('.cards-track');
                    return track ? track.children.length : 0;
                })()
            ", containerRef);
        }
        catch
        {
            totalCards = 5; // Fallback
        }
    }

    public async Task NavigateToCard(int index)
    {
        if (index < 0 || index >= totalCards) return;
        
        currentIndex = index;
        
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", $@"
                (function() {{
                    const track = arguments[0].querySelector('.cards-track');
                    if (track) {{
                        track.style.transition = 'transform {AnimationDuration}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        track.style.transform = 'translateX(-{currentIndex * 100}%)';
                    }}
                }})()
            ", containerRef);
        }
        catch
        {
            // Handle JS errors gracefully
        }
        
        if (OnCardSwipe.HasDelegate)
        {
            await OnCardSwipe.InvokeAsync(currentIndex);
        }
        
        StateHasChanged();
    }

    [JSInvokable]
    public static async Task OnSwipeNavigate(int newIndex)
    {
        // This method would be called from JavaScript
        // In a real implementation, we'd need to track instances
        // For now, this is a placeholder for the swipe callback
    }

    public async Task NextCard()
    {
        if (currentIndex < totalCards - 1)
        {
            await NavigateToCard(currentIndex + 1);
        }
    }

    public async Task PreviousCard()
    {
        if (currentIndex > 0)
        {
            await NavigateToCard(currentIndex - 1);
        }
    }

    public int GetCurrentIndex() => currentIndex;
    public int GetTotalCards() => totalCards;
}

<style>
    .swipeable-cards {
        overflow: hidden;
        position: relative;
        width: 100%;
        touch-action: pan-y; /* Allow vertical scrolling but handle horizontal */
        user-select: none;
    }

    .cards-track {
        display: flex;
        width: 100%;
        transition: transform 300ms cubic-bezier(0.25, 0.46, 0.45, 0.94);
        will-change: transform;
    }

    .cards-track > * {
        flex: 0 0 100%;
        width: 100%;
    }

    /* Smooth hardware acceleration */
    .swipeable-cards,
    .cards-track {
        backface-visibility: hidden;
        perspective: 1000px;
        transform-style: preserve-3d;
    }

    /* Disable text selection during swipe */
    .swipeable-cards.dragging {
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
    }

    /* Visual feedback for swipe areas */
    .swipeable-cards::before,
    .swipeable-cards::after {
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        width: 20px;
        z-index: 1;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .swipeable-cards::before {
        left: 0;
        background: linear-gradient(to right, rgba(0,0,0,0.1), transparent);
    }

    .swipeable-cards::after {
        right: 0;
        background: linear-gradient(to left, rgba(0,0,0,0.1), transparent);
    }

    .swipeable-cards:hover::before,
    .swipeable-cards:hover::after {
        opacity: 1;
    }

    /* Accessibility improvements */
    @@media (prefers-reduced-motion: reduce) {
        .cards-track {
            transition: none !important;
        }
    }

    /* High contrast mode */
    @@media (prefers-contrast: high) {
        .swipeable-cards::before {
            background: linear-gradient(to right, rgba(0,0,0,0.5), transparent);
        }

        .swipeable-cards::after {
            background: linear-gradient(to left, rgba(0,0,0,0.5), transparent);
        }
    }
</style>